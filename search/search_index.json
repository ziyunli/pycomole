{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pycomole","text":"<p>Documentation: https://ziyunli.github.io/pycomole</p> <p>Source Code: https://github.com/ziyunli/pycomole</p> <p>Coding exercises in Python.</p>"},{"location":"#development","title":"Development","text":"<p>Requirements:</p> <ul> <li>Nix: the package manager</li> <li>direnv</li> <li>devenv</li> </ul>"},{"location":"#activate-the-development-environment","title":"Activate the development environment","text":"<pre><code>devenv shell\npoetry env use python\npoetry install\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the docs directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github project page   automatically as part each release.</p> <p>You can run it locally via:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatters (e.g. <code>black</code>, <code>isort</code>), linters (e.g. <code>mypy</code>, <code>flake8</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This project was generated using the wolt-python-package-cookiecutter template.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"solutions/cs9/","title":"Stanford CS 9","text":"<p>Problem-Solving for the CS Technical Interview</p> <p>Modules exported by this package:</p> <ul> <li><code>arrays</code>: array-related problems</li> <li><code>strings</code>: string-related problems</li> <li><code>trees</code>: tree-related problems</li> </ul>"},{"location":"solutions/cs9/#cs9.arrays.dedup","title":"<code>dedup(lst)</code>","text":"<p>Returns a copy of the input list with duplicates removed.         Preserve order in the original list as much as possible             (keep first occurrence).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dedup([\"a\", \"b\", \"a\", \"c\", \"b\"])\n['a', 'b', 'c']\n&gt;&gt;&gt; dedup([\"foo\", \"bar\", \"baz\", \"foo\", \"bar\"])\n['foo', 'bar', 'baz']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>lst</code> <code>List[str]</code> <p>The input list to deduplicate</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>a copy of the input list with duplicates removed</p> Notes <ul> <li>The perfect use case for a set.</li> <li>If Set is not available, use a dictionary/hash map.</li> </ul> Source code in <code>src/cs9/arrays.py</code> <pre><code>def dedup(lst: List[str]) -&gt; List[str]:\n\"\"\"\n    Returns a copy of the input list with duplicates removed. \\\n        Preserve order in the original list as much as possible \\\n            (keep first occurrence).\n\n    Examples:\n        &gt;&gt;&gt; dedup([\"a\", \"b\", \"a\", \"c\", \"b\"])\n        ['a', 'b', 'c']\n        &gt;&gt;&gt; dedup([\"foo\", \"bar\", \"baz\", \"foo\", \"bar\"])\n        ['foo', 'bar', 'baz']\n\n    Args:\n        lst: The input list to deduplicate\n\n    Returns:\n        a copy of the input list with duplicates removed\n\n    Notes:\n        - The perfect use case for a set.\n        - If Set is not available, use a dictionary/hash map.\n    \"\"\"\n    found = set()\n    results = []\n    for w in lst:\n        if w not in found:\n            results.append(w)\n            found.add(w)\n    return results\n</code></pre>"},{"location":"solutions/cs9/#cs9.arrays.keep_nth_occurrences","title":"<code>keep_nth_occurrences(lst, n)</code>","text":"<p>Returns a copy of the input list that keeps nth occurrence.         Preserve order in the original list as much as possible.  Examples:     &gt;&gt;&gt; keep_nth_occurrences([\"a\", \"b\", \"a\", \"c\", \"b\"], 1)     ['a', 'b', 'c']     &gt;&gt;&gt; keep_nth_occurrences([\"foo\", \"bar\", \"baz\", \"foo\", \"bar\"], 2)     [\"foo\", \"bar\", \"baz\", \"foo\", \"bar\"]</p> <p>Parameters:</p> Name Type Description Default <code>lst</code> <code>List[str]</code> <p>The input list to deduplicate</p> required <code>n</code> <code>int</code> <p>The nth occurrence to keep</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>a copy of the input list that keeps nth occurrence.</p> Notes <ul> <li>Think about where a string has fewer than n occurrences.             Note we keep it in the result, but alternative you can                 only include nth occurrence if it exists.</li> </ul> Source code in <code>src/cs9/arrays.py</code> <pre><code>def keep_nth_occurrences(lst: List[str], n: int) -&gt; List[str]:\n\"\"\"\n    Returns a copy of the input list that keeps nth occurrence. \\\n        Preserve order in the original list as much as possible. \\\n\n    Examples:\n        &gt;&gt;&gt; keep_nth_occurrences([\"a\", \"b\", \"a\", \"c\", \"b\"], 1)\n        ['a', 'b', 'c']\n        &gt;&gt;&gt; keep_nth_occurrences([\"foo\", \"bar\", \"baz\", \"foo\", \"bar\"], 2)\n        [\"foo\", \"bar\", \"baz\", \"foo\", \"bar\"]\n\n    Args:\n        lst: The input list to deduplicate\n        n: The nth occurrence to keep\n\n    Returns:\n        a copy of the input list that keeps nth occurrence.\n\n    Notes:\n        - Think about where a string has fewer than n occurrences. \\\n            Note we keep it in the result, but alternative you can \\\n                only include nth occurrence if it exists.\n    \"\"\"\n    if n &lt; 1:\n        return []\n\n    if n == 1:\n        return dedup(lst)\n\n    found: Dict[str, int] = defaultdict(int)\n    results = []\n    for w in lst:\n        if w not in found or found[w] &lt; n:\n            found[w] += 1\n            results.append(w)\n    return results\n</code></pre>"},{"location":"solutions/cs9/#cs9.arrays.two_sum","title":"<code>two_sum(nums, target)</code>","text":"<p>Given a list of numbers and a target number, return the indices         of the two numbers that add up to the target.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; two_sum([2, 7, 11, 15], 9)\n[0, 1]\n&gt;&gt;&gt; two_sum([3, 2, 4], 6)\n[1, 2]\n&gt;&gt;&gt; two_sum([3, 3], 6)\n[0, 1]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>nums</code> <code>List[int]</code> <p>The list of numbers</p> required <code>target</code> <code>int</code> <p>The target number</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>The indices of the two numbers that add up to the target</p> Notes <ul> <li>Use a dictionary to keep track of the number and its index</li> </ul> Source code in <code>src/cs9/arrays.py</code> <pre><code>def two_sum(nums: List[int], target: int) -&gt; List[int]:\n\"\"\"\n    Given a list of numbers and a target number, return the indices \\\n        of the two numbers that add up to the target.\n\n    Examples:\n        &gt;&gt;&gt; two_sum([2, 7, 11, 15], 9)\n        [0, 1]\n        &gt;&gt;&gt; two_sum([3, 2, 4], 6)\n        [1, 2]\n        &gt;&gt;&gt; two_sum([3, 3], 6)\n        [0, 1]\n\n    Args:\n        nums: The list of numbers\n        target: The target number\n\n    Returns:\n        The indices of the two numbers that add up to the target\n\n    Notes:\n        - Use a dictionary to keep track of the number and its index\n    \"\"\"\n    found: Dict[int, int] = {}\n    for i, n in enumerate(nums):\n        if target - n in found:\n            return [found[target - n], i]\n        found[n] = i\n\n    return []\n</code></pre>"},{"location":"solutions/cs9/#cs9.strings.abbrev","title":"<code>abbrev(s)</code>","text":"<p>Returns an abbreviation form         <code>&lt;first letter&gt; &lt;number of omitted letters&gt; &lt;last letter&gt;</code>             of the input string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; abbrev(\"internationalization\")\ni18n\n&gt;&gt;&gt; abbrev(\"localization\")\nl10n\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the input string</p> required <p>Returns:</p> Type Description <code>str</code> <p>An abbreviation of the input string in the form of             <code>&lt;first letter&gt; &lt;number of omitted letters&gt; &lt;last letter&gt;.</code></p> Notes <ul> <li>Handle edge cases where the input string is too short             e.g. 0-, 1-, 2-, 3-letter strings)</li> <li>Clarify if the input has non-alphabet letters</li> </ul> Source code in <code>src/cs9/strings.py</code> <pre><code>def abbrev(s: str) -&gt; str:\n\"\"\"\n    Returns an abbreviation form \\\n        `&lt;first letter&gt; &lt;number of omitted letters&gt; &lt;last letter&gt;` \\\n            of the input string.\n\n    Examples:\n        &gt;&gt;&gt; abbrev(\"internationalization\")\n        i18n\n        &gt;&gt;&gt; abbrev(\"localization\")\n        l10n\n\n    Args:\n        s: the input string\n\n    Returns:\n        An abbreviation of the input string in the form of \\\n            `&lt;first letter&gt; &lt;number of omitted letters&gt; &lt;last letter&gt;.`\n\n    Notes:\n        - Handle edge cases where the input string is too short \\\n            e.g. 0-, 1-, 2-, 3-letter strings)\n        - Clarify if the input has non-alphabet letters\n    \"\"\"\n    if len(s) &lt;= 3:\n        return s  # Nothing to abbrev\n\n    head = s[0]\n    tail = s[-1]\n    return \"\".join([head, str(len(s) - 2), tail])\n</code></pre>"},{"location":"solutions/cs9/#cs9.strings.anagram","title":"<code>anagram(s, t)</code>","text":"<p>Checks if the given two strings to be anagram of each other. Two strings are said to be anagrams of one another if you can turn         the first string into the second by rearranging its letters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; anagram(\"table\", \"bleat\")\nTrue\n&gt;&gt;&gt; anagram(\"foo\", \"bar\")\nFalse\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The first string</p> required <code>t</code> <code>str</code> <p>The second string</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the given two strings are anagrams             of each other</p> Notes <ul> <li>Anagrams always have the same length</li> <li>Use a dictionary to keep track of the letter counts (histogram)</li> </ul> Source code in <code>src/cs9/strings.py</code> <pre><code>def anagram(s: str, t: str) -&gt; bool:\n\"\"\"\n    Checks if the given two strings to be anagram of each other.\n    Two strings are said to be anagrams of one another if you can turn \\\n        the first string into the second by rearranging its letters.\n\n    Examples:\n        &gt;&gt;&gt; anagram(\"table\", \"bleat\")\n        True\n        &gt;&gt;&gt; anagram(\"foo\", \"bar\")\n        False\n\n    Args:\n        s: The first string\n        t: The second string\n\n    Returns:\n        A boolean indicating whether the given two strings are anagrams \\\n            of each other\n\n    Notes:\n        - Anagrams always have the same length\n        - Use a dictionary to keep track of the letter counts (histogram)\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    histogram_s: Dict[str, int] = defaultdict(int)\n    for ch in s.lower():\n        histogram_s[ch] += 1\n\n    histogram_t: Dict[str, int] = defaultdict(int)\n    for ch in t.lower():\n        histogram_t[ch] += 1\n\n    return histogram_s == histogram_t\n</code></pre>"},{"location":"solutions/cs9/#cs9.strings.has_balanced_brackets","title":"<code>has_balanced_brackets(s)</code>","text":"<p>Checks if a string has balanced brackets \"()\", \"[]\" or \"{}\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; has_balanced_brackets(\"()[]{}\")\nTrue\n&gt;&gt;&gt; has_balanced_brackets(\"(\")\nFalse\n&gt;&gt;&gt; has_balanced_brackets(\"([)]\")\nFalse\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The input string to check for balanced brackets</p> required <p>Returns:</p> Type Description <code>bool</code> <p>a boolean indicating whether the given string has balanced             brackets</p> Notes <ul> <li>A good place to use stack to keep track of open brackets</li> <li>Note that the input string can have other characters</li> <li>Use hash to map opening brackets to closing brackets</li> </ul> Source code in <code>src/cs9/strings.py</code> <pre><code>def has_balanced_brackets(s: str) -&gt; bool:\n\"\"\"\n    Checks if a string has balanced brackets \"()\", \"[]\" or \"{}\".\n\n    Examples:\n        &gt;&gt;&gt; has_balanced_brackets(\"()[]{}\")\n        True\n        &gt;&gt;&gt; has_balanced_brackets(\"(\")\n        False\n        &gt;&gt;&gt; has_balanced_brackets(\"([)]\")\n        False\n\n    Args:\n        s: The input string to check for balanced brackets\n\n    Returns:\n        a boolean indicating whether the given string has balanced \\\n            brackets\n\n    Notes:\n        - A good place to use stack to keep track of open brackets\n        - Note that the input string can have other characters\n        - Use hash to map opening brackets to closing brackets\n    \"\"\"\n    stack = []\n    matching_pairs = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n    }\n    for c in s:\n        if c in [\"(\", \"[\", \"{\"]:\n            stack.append(c)\n        elif c in [\")\", \"]\", \"}\"]:\n            if not stack:\n                return False\n            if matching_pairs[stack.pop()] != c:\n                return False\n    return not stack\n</code></pre>"},{"location":"solutions/cs9/#cs9.strings.has_balanced_parentheses","title":"<code>has_balanced_parentheses(s)</code>","text":"<p>Checks if a string has balanced parentheses</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; has_balanced_parentheses(\"()\")\nTrue\n&gt;&gt;&gt; has_balanced_parentheses(\"(()\")\nFalse\n&gt;&gt;&gt; has_balanced_parentheses(\"(test)\")\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The input string to check for balanced parentheses</p> required <p>Returns:</p> Type Description <code>bool</code> <p>a boolean indicating whether the given string has balanced             parentheses</p> Notes <ul> <li>A good place to use stack to keep track of open parentheses</li> <li>Note that the input string can have other characters</li> </ul> Source code in <code>src/cs9/strings.py</code> <pre><code>def has_balanced_parentheses(s: str) -&gt; bool:\n\"\"\"\n    Checks if a string has balanced parentheses\n\n    Examples:\n        &gt;&gt;&gt; has_balanced_parentheses(\"()\")\n        True\n        &gt;&gt;&gt; has_balanced_parentheses(\"(()\")\n        False\n        &gt;&gt;&gt; has_balanced_parentheses(\"(test)\")\n        True\n\n    Args:\n        s: The input string to check for balanced parentheses\n\n    Returns:\n        a boolean indicating whether the given string has balanced \\\n            parentheses\n\n    Notes:\n        - A good place to use stack to keep track of open parentheses\n        - Note that the input string can have other characters\n    \"\"\"\n    stack = []\n    for c in s:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n</code></pre>"},{"location":"solutions/cs9/#cs9.strings.longest_contiguous_substring","title":"<code>longest_contiguous_substring(s)</code>","text":"<p>Return the longest contiguous substring of 2 distinct characters         from an input string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; longest_contiguous_substring(\"abbaacab\")\nabbaa\n&gt;&gt;&gt; longest_contiguous_substring(\"abcefabbabaabefghghfa\")\nabbabaab\n&gt;&gt;&gt; longest_contiguous_substring(\"aabceddddcdccecabceftg\")\nddddcdcc\n&gt;&gt;&gt; longest_contiguous_substring(\"acbabbcbca\")\nbbcbc\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The input string</p> required <p>Returns:</p> Type Description <code>str</code> <p>The longest contiguous substring of 2 distinct characters             from the input string</p> Notes <ul> <li>Use a dictionary to keep the latest 2 distinct characters             and when they first show up</li> <li>Use a sliding window to keep track of the longest substring</li> </ul> Source code in <code>src/cs9/strings.py</code> <pre><code>def longest_contiguous_substring(s: str) -&gt; str:\n\"\"\"\n    Return the longest contiguous substring of 2 distinct characters \\\n        from an input string.\n\n    Examples:\n        &gt;&gt;&gt; longest_contiguous_substring(\"abbaacab\")\n        abbaa\n        &gt;&gt;&gt; longest_contiguous_substring(\"abcefabbabaabefghghfa\")\n        abbabaab\n        &gt;&gt;&gt; longest_contiguous_substring(\"aabceddddcdccecabceftg\")\n        ddddcdcc\n        &gt;&gt;&gt; longest_contiguous_substring(\"acbabbcbca\")\n        bbcbc\n\n    Args:\n        s: The input string\n\n    Returns:\n        The longest contiguous substring of 2 distinct characters \\\n            from the input string\n\n    Notes:\n        - Use a dictionary to keep the latest 2 distinct characters \\\n            and when they first show up\n        - Use a sliding window to keep track of the longest substring\n    \"\"\"\n    if len(s) &lt; 2:\n        return \"\"\n\n    if len(s) == 2:\n        if len(set(s)) == 2:\n            return s\n        else:\n            return \"\"\n\n    longest = \"\"\n    start = 0  # sliding window is [start, i)\n    chars: Set[str] = set()\n    for i, c in enumerate(s):\n        if len(chars) &lt; 2:\n            chars.add(c)\n        else:  # len(chars) == 2\n            if c not in chars:\n                # See if we have a new longest substring\n                if i - start &gt; len(longest):\n                    longest = s[start:i]\n                # Find the new starting index of the sliding window\n                start = i - 1\n                while start &gt; 0:\n                    if s[start - 1] != s[start]:\n                        break\n                    start -= 1\n                # Remote the other character\n                chars.remove(s[start - 1])\n                # Add the new character\n                chars.add(c)\n    return longest\n</code></pre>"},{"location":"solutions/cs9/#cs9.strings.reverse_words","title":"<code>reverse_words(s)</code>","text":"<p>Reverses the order of the letters in each word from the input while preserving the word order and spacing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; reverse_words(\"moo cow bark dog\")\noom woc krab god\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>An input string</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string that reverses the order of the letters in each word             from the input while preserving the word order and spacing</p> Notes <ul> <li>Clarify how many spaces/tabs/newlines are between words</li> <li>A naive approach is to split the string into words using split()         and reverse the words using reverse() and then join the words</li> <li>A more efficient approach is to use a stack in a single pass</li> </ul> Source code in <code>src/cs9/strings.py</code> <pre><code>def reverse_words(s: str) -&gt; str:\n\"\"\"\n    Reverses the order of the letters in each word from the input\n    while preserving the word order and spacing.\n\n    Examples:\n        &gt;&gt;&gt; reverse_words(\"moo cow bark dog\")\n        oom woc krab god\n\n    Args:\n        s: An input string\n\n    Returns:\n        A string that reverses the order of the letters in each word \\\n            from the input while preserving the word order and spacing\n\n    Notes:\n        - Clarify how many spaces/tabs/newlines are between words\n        - A naive approach is to split the string into words using split() \\\n        and reverse the words using reverse() and then join the words\n        - A more efficient approach is to use a stack in a single pass\n    \"\"\"\n    results = []\n    stack = []\n    for c in s:\n        # Assume the string only has alphabet and numeric characters\n        if c.isalnum():\n            stack.append(c)\n        else:\n            while stack:\n                results.append(stack.pop())\n            results.append(c)  # preserve the same number of spaces\n\n    while stack:\n        results.append(stack.pop())\n    return \"\".join(results)\n</code></pre>"},{"location":"solutions/cs9/#cs9.trees.Node","title":"<code>Node</code>  <code>dataclass</code>","text":"<p>A node in a rooted binary tree with a pointer to its parent</p> Source code in <code>src/cs9/trees.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass Node:\n\"\"\"A node in a rooted binary tree with a pointer to its parent\"\"\"\n\n    parent: Optional[\"Node\"]\n    value: str\n</code></pre>"},{"location":"solutions/cs9/#cs9.trees.has_common_non_root_ancestor","title":"<code>has_common_non_root_ancestor(root, a, b)</code>","text":"<p>Determines whether the two nodes have a common ancestor besides         the root.</p> <p>Examples:</p> <pre><code>       root\n      /    \\\n     a       b\n   /   \\    /  \\\n  c     d  e    f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[Node]</code> <p>The root of a binary tree</p> required <code>a</code> <code>Optional[Node]</code> <p>node 1 in the same binary tree</p> required <code>b</code> <code>Optional[Node]</code> <p>node 2 in the same binary tree</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating if the two nodes have a common ancestor             besides the root</p> Notes <ul> <li>Clarify if a node counts as its own ancestor, e.g.             has_common_non_root_ancestor(root, a, c).                 Here we assume (a, c) share an ancestor a.</li> <li>Using hash is easier but takes a bit extra memory space.</li> </ul> Source code in <code>src/cs9/trees.py</code> <pre><code>def has_common_non_root_ancestor(\n    root: Optional[Node], a: Optional[Node], b: Optional[Node]\n) -&gt; bool:\n\"\"\"\n    Determines whether the two nodes have a common ancestor besides \\\n        the root.\n\n    Examples:\n    ```\n           root\n          /    \\\\\n         a       b\n       /   \\\\    /  \\\\\n      c     d  e    f\n    ```\n\n    Args:\n        root: The root of a binary tree\n        a: node 1 in the same binary tree\n        b: node 2 in the same binary tree\n\n    Returns:\n        A boolean indicating if the two nodes have a common ancestor \\\n            besides the root\n\n    Notes:\n        - Clarify if a node counts as its own ancestor, e.g. \\\n            has_common_non_root_ancestor(root, a, c). \\\n                Here we assume (a, c) share an ancestor a.\n        - Using hash is easier but takes a bit extra memory space.\n    \"\"\"\n    if not (root and a and b):\n        return False\n\n    ancestors = set()\n    while a is not None and a != root:\n        ancestors.add(a)\n        a = a.parent\n\n    while b is not None and b != root:\n        if b in ancestors:\n            return True\n        b = b.parent\n\n    return False\n</code></pre>"}]}